# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_BaltNet.ipynb.

# %% auto 0
__all__ = ['BaltNet', 'BaseLineModel', 'LightningModel', 'AtmosphericDataset', 'AtmosphereDataModule']

# %% ../nbs/02_BaltNet.ipynb 2
import torch
import torch.nn as nn
import lightning as L
from lightning.pytorch.callbacks import ModelCheckpoint
import numpy as np

from torch.utils.data import DataLoader, Dataset
from torch.utils.data.dataset import random_split
import torch.nn.functional as F
import torchmetrics
from lightning.pytorch.loggers import CSVLogger

import xarray as xr
from glob import glob
from tqdm import tqdm

from .convLSTM import ConvLSTM
from .sharedUtilities import read_netcdfs, preprocess, plot_loss_and_acc

# %% ../nbs/02_BaltNet.ipynb 3
class BaltNet(nn.Module):
    def __init__(self, modelPar):
        super(BaltNet, self).__init__()

        # initialize all attributes
        for k, v in modelPar.items():
            setattr(self, k, v)

        self.linear_dim = self.dimensions[0]*self.dimensions[1]*self.hidden_dim

        self.convLSTM = ConvLSTM(
                input_dim=self.input_dim,
                hidden_dim=self.hidden_dim,
                kernel_size=self.kernel_size,
                num_layers=self.num_layers,
                batch_first=self.batch_first,
                bias=self.bias,
                return_all_layers=self.return_all_layers
        )

        self.convLSTM2 = ConvLSTM(
                input_dim=self.input_dim,
                hidden_dim=self.hidden_dim,
                kernel_size=self.kernel_size,
                num_layers=1,
                batch_first=self.batch_first,
                bias=self.bias,
                return_all_layers=self.return_all_layers
        )

        self.fc_layers = torch.nn.Sequential(
            torch.nn.Linear(self.linear_dim, 512),
            torch.nn.ReLU(),
            torch.nn.Linear(512, 256),
            torch.nn.ReLU(),
            torch.nn.Linear(256, 97)
            )

    def forward(self, x):
        _, encode_state = self.convLSTM(x)
        decoder_out, _ = self.convLSTM2(x[:,-1:,:,:,:], encode_state)
        x = decoder_out[0]
        x = torch.flatten(x, start_dim=1)
        x = self.fc_layers(x).squeeze()
        return x


# %% ../nbs/02_BaltNet.ipynb 4
class BaseLineModel(nn.Module):
    def __init__(self, modelPar):
        super(BaseLineModel, self).__init__()

        # initialize all attributes
        for k, v in modelPar.items():
            setattr(self, k, v)

        self.linear_dim = self.dimensions[0]*self.dimensions[1]*self.hidden_dim*self.input_dim

        self.fc_layers = torch.nn.Sequential(
            torch.nn.Linear(self.linear_dim, 256),
            torch.nn.ReLU(),
            torch.nn.Linear(256, 1)
            )
        
    def forward(self, x):
        x = torch.flatten(x, start_dim=1)
        x = self.fc_layers(x).squeeze()
        return x

# %% ../nbs/02_BaltNet.ipynb 5
class LightningModel(L.LightningModule):
    def __init__(self, model, learning_rate, cosine_t_max):
        super().__init__()

        self.learning_rate = learning_rate
        self.model = model
        self.cosine_t_max = cosine_t_max

        self.save_hyperparameters(ignore=["model"])

        self.train_mse = torchmetrics.MeanSquaredError()
        self.val_mse = torchmetrics.MeanSquaredError()
        self.test_mse = torchmetrics.MeanSquaredError()

    def forward(self, x):
        return self.model(x)
    
    def _shared_step(self, batch, debug=False):
        features, true_labels = batch
        logits = self.model(features)
        loss = F.mse_loss(logits, true_labels)
        if debug == True:
            print(loss)
        return loss, true_labels, logits
    
    def training_step(self, batch, batch_idx):
        loss, true_labels, predicted_labels = self._shared_step(batch, debug=False)
        mse = self.train_mse(predicted_labels, true_labels)
        metrics = {"train_mse":mse, "train_loss":loss}
        self.log_dict(metrics, on_step=True, on_epoch=True, prog_bar=True,logger=True, sync_dist=True)
        return loss
    
    def validation_step(self, batch, batch_idx):
        loss, true_labes, predicted_labels = self._shared_step(batch)
        self.log("val_loss", loss, sync_dist=True)
        self.val_mse(predicted_labels, true_labes)
        self.log(
            "val_mse", self.val_mse, prog_bar=True, sync_dist=True
        )
    
    def test_step(self, batch, _):
        loss, true_labels, predicted_labels = self._shared_step(batch)
        self.test_mse(predicted_labels, true_labels)
        self.log("test_loss", loss, rank_zero_only=True)
        self.log("test_mse", self.test_mse, sync_dist=True)
        return loss
    
    def predict_step(self, batch, batch_idx: int, dataloader_idx: int = 0):
        _, _, predicted_labels = self._shared_step(batch)
        return predicted_labels

    
    def configure_optimizers(self):
        opt = torch.optim.Adam(self.parameters(), lr=self.learning_rate)
        sch = torch.optim.lr_scheduler.CosineAnnealingLR(opt, T_max=self.cosine_t_max)

        return [opt], [sch]


# %% ../nbs/02_BaltNet.ipynb 6
class AtmosphericDataset(Dataset):
    def __init__(self, datapath, transform=None):

        data = read_netcdfs(
            files=f"{datapath}/atmosphericForcing/????/rain.mom.dta.nc",
            dim="time",
            transform_func=lambda ds:preprocess(ds)
            )       

        runoff = read_netcdfs(
            f"{datapath}/runoffData/combined_fastriver_*.nc",
            dim="river",
            transform_func= lambda ds:ds.roflux.resample(time="1D").mean(),
            cftime=False
            )
        
        runoff = runoff.transpose("time", "river")
        runoff = runoff.sel(time=slice(None, str(2017)))

        rainData = data["RAIN"]
        runoffData = runoff.sel(time=slice(str(rainData.time.min().data), str(rainData.time.max().data)))

        rainDataMean = rainData.mean()
        rainDataSTD = rainData.std()
        runoffDataMean = runoffData.mean("time")
        runoffDataSTD = runoffData.std("time")

        self.rainData = (rainDataMean, rainDataSTD)
        self.runoffData = (runoffDataMean, runoffDataSTD)
        self.timeRange = (str(rainData.time.min().data), str(rainData.time.max().data))

        np.savetxt(
            "/silor/boergel/paper/runoff_prediction/data/runoffMeanStd.txt",
            [runoffDataMean, runoffDataSTD]
        )

        X = (rainData - rainData.mean())/rainData.std()
        y = (runoffData - runoffDataMean)/runoffDataSTD

        # TODO 
        # add dummy dimension in only one atmospheric data file
        # is loaded
        
        X = torch.tensor(X.compute().data, dtype=torch.float32)
        X = X.unsqueeze(dim=0)
        
        self.x = X
        self.y = torch.tensor(y.compute().data, dtype=torch.float32)

    def __getitem__(self, index):
        return self.x[:, index:index+30], self.y[index+30]

    def __len__(self):
        return self.y.shape[0]-30


# %% ../nbs/02_BaltNet.ipynb 7
class AtmosphereDataModule(L.LightningDataModule):
    def __init__(self, datapath, batch_size=64, num_workers=8, add_first_dim=True):
        super().__init__()
        self.data_dir = datapath
        self.batch_size = batch_size
        self.num_workers = num_workers
        self.add_first_dim = add_first_dim
        
    def setup(self, stage:str):
        UserWarning("Loading atmospheric data ...")
        dataset = AtmosphericDataset(datapath=self.data_dir)
        n_samples = len(dataset)
        train_size = int(0.8 * n_samples)
        val_size = int(0.1 * n_samples)
        test_size = n_samples - train_size - val_size
        self.train, self.val, self.test = random_split(dataset, [train_size, val_size, test_size])

    def train_dataloader(self):
        return DataLoader(
            dataset=self.train,
            batch_size=self.batch_size,
            shuffle=True, 
            drop_last=True, 
            num_workers=self.num_workers)
    
    def val_dataloader(self):
        return DataLoader(
            dataset=self.val,
            batch_size=self.batch_size,
            shuffle=False,
            num_workers=self.num_workers,
            drop_last=True)

    def test_dataloader(self):
        return DataLoader(
            self.test,
            batch_size=self.batch_size,
            shuffle=False,
            num_workers=self.num_workers, 
            drop_last=True)
